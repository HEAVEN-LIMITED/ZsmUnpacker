package zsm;

import SevenZip.Compression.LZMA.Decoder;
import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.BufferedReader;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.DataOutputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.RandomAccessFile;
import java.io.UnsupportedEncodingException;
import java.net.HttpURLConnection;
import java.net.URL;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.Arrays;
import java.util.Objects;
import java.util.UUID;

public class ZsmPatcher {
	
	public static void main(String[] c) throws IOException, Throwable {
		String Body = "tarce log algo auto compstr null value";
		URL url = new URL("http://" + "14.146.227.141:7001" + "/ticket.cgi");
		Result result = doPost(url, Body, null);
		byte[] zsmBytes = result.result;
		OutputStream out = new BufferedOutputStream(new FileOutputStream("out", false));
		out.write(patch(zsmBytes));
		if (out != null) {
			out.close();
		}
	}

	// 32 bit LittleEndian
	private static long[] xkey = new long[] { 0x00000000 & 0xffffffffL, 0x00000000 & 0xffffffffL,
			0x00000000 & 0xffffffffL, 0x00000000 & 0xffffffffL, 0x00000000 & 0xffffffffL, 0x00000000 & 0xffffffffL,
			0x3444D771 & 0xffffffffL, 0x26A6BC48 & 0xffffffffL, 0x25626B4E & 0xffffffffL, 0x1B935E6C & 0xffffffffL,
			0x22578973 & 0xffffffffL, 0x2A35E243 & 0xffffffffL, 0x27713541 & 0xffffffffL, 0x3889AF63 & 0xffffffffL,
			0x32CD7836 & 0xffffffffL, 0x33AF1349 & 0xffffffffL, 0x2A6BC453 & 0xffffffffL, 0x141AF133 & 0xffffffffL,
			0x3ADE2677 & 0xffffffffL, 0x3B3C4D63 & 0xffffffffL, 0x1A789A7A & 0xffffffffL, 0x1BC7AC4E & 0xffffffffL };
	private static int[] box1 = new int[] { 0x3E & 0xff, 0x72 & 0xff, 0x5B & 0xff, 0x47 & 0xff, 0xCA & 0xff,
			0xE0 & 0xff, 0x00 & 0xff, 0x33 & 0xff, 0x04 & 0xff, 0xD1 & 0xff, 0x54 & 0xff, 0x98 & 0xff, 0x09 & 0xff,
			0xB9 & 0xff, 0x6D & 0xff, 0xCB & 0xff, 0x7B & 0xff, 0x1B & 0xff, 0xF9 & 0xff, 0x32 & 0xff, 0xAF & 0xff,
			0x9D & 0xff, 0x6A & 0xff, 0xA5 & 0xff, 0xB8 & 0xff, 0x2D & 0xff, 0xFC & 0xff, 0x1D & 0xff, 0x08 & 0xff,
			0x53 & 0xff, 0x03 & 0xff, 0x90 & 0xff, 0x4D & 0xff, 0x4E & 0xff, 0x84 & 0xff, 0x99 & 0xff, 0xE4 & 0xff,
			0xCE & 0xff, 0xD9 & 0xff, 0x91 & 0xff, 0xDD & 0xff, 0xB6 & 0xff, 0x85 & 0xff, 0x48 & 0xff, 0x8B & 0xff,
			0x29 & 0xff, 0x6E & 0xff, 0xAC & 0xff, 0xCD & 0xff, 0xC1 & 0xff, 0xF8 & 0xff, 0x1E & 0xff, 0x73 & 0xff,
			0x43 & 0xff, 0x69 & 0xff, 0xC6 & 0xff, 0xB5 & 0xff, 0xBD & 0xff, 0xFD & 0xff, 0x39 & 0xff, 0x63 & 0xff,
			0x20 & 0xff, 0xD4 & 0xff, 0x38 & 0xff, 0x76 & 0xff, 0x7D & 0xff, 0xB2 & 0xff, 0xA7 & 0xff, 0xCF & 0xff,
			0xED & 0xff, 0x57 & 0xff, 0xC5 & 0xff, 0xF3 & 0xff, 0x2C & 0xff, 0xBB & 0xff, 0x14 & 0xff, 0x21 & 0xff,
			0x06 & 0xff, 0x55 & 0xff, 0x9B & 0xff, 0xE3 & 0xff, 0xEF & 0xff, 0x5E & 0xff, 0x31 & 0xff, 0x4F & 0xff,
			0x7F & 0xff, 0x5A & 0xff, 0xA4 & 0xff, 0x0D & 0xff, 0x82 & 0xff, 0x51 & 0xff, 0x49 & 0xff, 0x5F & 0xff,
			0xBA & 0xff, 0x58 & 0xff, 0x1C & 0xff, 0x4A & 0xff, 0x16 & 0xff, 0xD5 & 0xff, 0x17 & 0xff, 0xA8 & 0xff,
			0x92 & 0xff, 0x24 & 0xff, 0x1F & 0xff, 0x8C & 0xff, 0xFF & 0xff, 0xD8 & 0xff, 0xAE & 0xff, 0x2E & 0xff,
			0x01 & 0xff, 0xD3 & 0xff, 0xAD & 0xff, 0x3B & 0xff, 0x4B & 0xff, 0xDA & 0xff, 0x46 & 0xff, 0xEB & 0xff,
			0xC9 & 0xff, 0xDE & 0xff, 0x9A & 0xff, 0x8F & 0xff, 0x87 & 0xff, 0xD7 & 0xff, 0x3A & 0xff, 0x80 & 0xff,
			0x6F & 0xff, 0x2F & 0xff, 0xC8 & 0xff, 0xB1 & 0xff, 0xB4 & 0xff, 0x37 & 0xff, 0xF7 & 0xff, 0x0A & 0xff,
			0x22 & 0xff, 0x13 & 0xff, 0x28 & 0xff, 0x7C & 0xff, 0xCC & 0xff, 0x3C & 0xff, 0x89 & 0xff, 0xC7 & 0xff,
			0xC3 & 0xff, 0x96 & 0xff, 0x56 & 0xff, 0x07 & 0xff, 0xBF & 0xff, 0x7E & 0xff, 0xF0 & 0xff, 0x0B & 0xff,
			0x2B & 0xff, 0x97 & 0xff, 0x52 & 0xff, 0x35 & 0xff, 0x41 & 0xff, 0x79 & 0xff, 0x61 & 0xff, 0xA6 & 0xff,
			0x4C & 0xff, 0x10 & 0xff, 0xFE & 0xff, 0xBC & 0xff, 0x26 & 0xff, 0x95 & 0xff, 0x88 & 0xff, 0x8A & 0xff,
			0xB0 & 0xff, 0xA3 & 0xff, 0xFB & 0xff, 0xC0 & 0xff, 0x18 & 0xff, 0x94 & 0xff, 0xF2 & 0xff, 0xE1 & 0xff,
			0xE5 & 0xff, 0xE9 & 0xff, 0x5D & 0xff, 0xD0 & 0xff, 0xDC & 0xff, 0x11 & 0xff, 0x66 & 0xff, 0x64 & 0xff,
			0x5C & 0xff, 0xEC & 0xff, 0x59 & 0xff, 0x42 & 0xff, 0x75 & 0xff, 0x12 & 0xff, 0xF5 & 0xff, 0x74 & 0xff,
			0x9C & 0xff, 0xAA & 0xff, 0x23 & 0xff, 0x0E & 0xff, 0x86 & 0xff, 0xAB & 0xff, 0xBE & 0xff, 0x2A & 0xff,
			0x02 & 0xff, 0xE7 & 0xff, 0x67 & 0xff, 0xE6 & 0xff, 0x44 & 0xff, 0xA2 & 0xff, 0x6C & 0xff, 0xC2 & 0xff,
			0x93 & 0xff, 0x9F & 0xff, 0xF1 & 0xff, 0xF6 & 0xff, 0xFA & 0xff, 0x36 & 0xff, 0xD2 & 0xff, 0x50 & 0xff,
			0x68 & 0xff, 0x9E & 0xff, 0x62 & 0xff, 0x71 & 0xff, 0x15 & 0xff, 0x3D & 0xff, 0xD6 & 0xff, 0x40 & 0xff,
			0xC4 & 0xff, 0xE2 & 0xff, 0x0F & 0xff, 0x8E & 0xff, 0x83 & 0xff, 0x77 & 0xff, 0x6B & 0xff, 0x25 & 0xff,
			0x05 & 0xff, 0x3F & 0xff, 0x0C & 0xff, 0x30 & 0xff, 0xEA & 0xff, 0x70 & 0xff, 0xB7 & 0xff, 0xA1 & 0xff,
			0xE8 & 0xff, 0xA9 & 0xff, 0x65 & 0xff, 0x8D & 0xff, 0x27 & 0xff, 0x1A & 0xff, 0xDB & 0xff, 0x81 & 0xff,
			0xB3 & 0xff, 0xA0 & 0xff, 0xF4 & 0xff, 0x45 & 0xff, 0x7A & 0xff, 0x19 & 0xff, 0xDF & 0xff, 0xEE & 0xff,
			0x78 & 0xff, 0x34 & 0xff, 0x60 & 0xff };
	private static int[] box2 = new int[] { 0x55 & 0xff, 0xC2 & 0xff, 0x63 & 0xff, 0x71 & 0xff, 0x3B & 0xff,
			0xC8 & 0xff, 0x47 & 0xff, 0x86 & 0xff, 0x9F & 0xff, 0x3C & 0xff, 0xDA & 0xff, 0x5B & 0xff, 0x29 & 0xff,
			0xAA & 0xff, 0xFD & 0xff, 0x77 & 0xff, 0x8C & 0xff, 0xC5 & 0xff, 0x94 & 0xff, 0x0C & 0xff, 0xA6 & 0xff,
			0x1A & 0xff, 0x13 & 0xff, 0x00 & 0xff, 0xE3 & 0xff, 0xA8 & 0xff, 0x16 & 0xff, 0x72 & 0xff, 0x40 & 0xff,
			0xF9 & 0xff, 0xF8 & 0xff, 0x42 & 0xff, 0x44 & 0xff, 0x26 & 0xff, 0x68 & 0xff, 0x96 & 0xff, 0x81 & 0xff,
			0xD9 & 0xff, 0x45 & 0xff, 0x3E & 0xff, 0x10 & 0xff, 0x76 & 0xff, 0xC6 & 0xff, 0xA7 & 0xff, 0x8B & 0xff,
			0x39 & 0xff, 0x43 & 0xff, 0xE1 & 0xff, 0x3A & 0xff, 0xB5 & 0xff, 0x56 & 0xff, 0x2A & 0xff, 0xC0 & 0xff,
			0x6D & 0xff, 0xB3 & 0xff, 0x05 & 0xff, 0x22 & 0xff, 0x66 & 0xff, 0xBF & 0xff, 0xDC & 0xff, 0x0B & 0xff,
			0xFA & 0xff, 0x62 & 0xff, 0x48 & 0xff, 0xDD & 0xff, 0x20 & 0xff, 0x11 & 0xff, 0x06 & 0xff, 0x36 & 0xff,
			0xC9 & 0xff, 0xC1 & 0xff, 0xCF & 0xff, 0xF6 & 0xff, 0x27 & 0xff, 0x52 & 0xff, 0xBB & 0xff, 0x69 & 0xff,
			0xF5 & 0xff, 0xD4 & 0xff, 0x87 & 0xff, 0x7F & 0xff, 0x84 & 0xff, 0x4C & 0xff, 0xD2 & 0xff, 0x9C & 0xff,
			0x57 & 0xff, 0xA4 & 0xff, 0xBC & 0xff, 0x4F & 0xff, 0x9A & 0xff, 0xDF & 0xff, 0xFE & 0xff, 0xD6 & 0xff,
			0x8D & 0xff, 0x7A & 0xff, 0xEB & 0xff, 0x2B & 0xff, 0x53 & 0xff, 0xD8 & 0xff, 0x5C & 0xff, 0xA1 & 0xff,
			0x14 & 0xff, 0x17 & 0xff, 0xFB & 0xff, 0x23 & 0xff, 0xD5 & 0xff, 0x7D & 0xff, 0x30 & 0xff, 0x67 & 0xff,
			0x73 & 0xff, 0x08 & 0xff, 0x09 & 0xff, 0xEE & 0xff, 0xB7 & 0xff, 0x70 & 0xff, 0x3F & 0xff, 0x61 & 0xff,
			0xB2 & 0xff, 0x19 & 0xff, 0x8E & 0xff, 0x4E & 0xff, 0xE5 & 0xff, 0x4B & 0xff, 0x93 & 0xff, 0x8F & 0xff,
			0x5D & 0xff, 0xDB & 0xff, 0xA9 & 0xff, 0xAD & 0xff, 0xF1 & 0xff, 0xAE & 0xff, 0x2E & 0xff, 0xCB & 0xff,
			0x0D & 0xff, 0xFC & 0xff, 0xF4 & 0xff, 0x2D & 0xff, 0x46 & 0xff, 0x6E & 0xff, 0x1D & 0xff, 0x97 & 0xff,
			0xE8 & 0xff, 0xD1 & 0xff, 0xE9 & 0xff, 0x4D & 0xff, 0x37 & 0xff, 0xA5 & 0xff, 0x75 & 0xff, 0x5E & 0xff,
			0x83 & 0xff, 0x9E & 0xff, 0xAB & 0xff, 0x82 & 0xff, 0x9D & 0xff, 0xB9 & 0xff, 0x1C & 0xff, 0xE0 & 0xff,
			0xCD & 0xff, 0x49 & 0xff, 0x89 & 0xff, 0x01 & 0xff, 0xB6 & 0xff, 0xBD & 0xff, 0x58 & 0xff, 0x24 & 0xff,
			0xA2 & 0xff, 0x5F & 0xff, 0x38 & 0xff, 0x78 & 0xff, 0x99 & 0xff, 0x15 & 0xff, 0x90 & 0xff, 0x50 & 0xff,
			0xB8 & 0xff, 0x95 & 0xff, 0xE4 & 0xff, 0xD0 & 0xff, 0x91 & 0xff, 0xC7 & 0xff, 0xCE & 0xff, 0xED & 0xff,
			0x0F & 0xff, 0xB4 & 0xff, 0x6F & 0xff, 0xA0 & 0xff, 0xCC & 0xff, 0xF0 & 0xff, 0x02 & 0xff, 0x4A & 0xff,
			0x79 & 0xff, 0xC3 & 0xff, 0xDE & 0xff, 0xA3 & 0xff, 0xEF & 0xff, 0xEA & 0xff, 0x51 & 0xff, 0xE6 & 0xff,
			0x6B & 0xff, 0x18 & 0xff, 0xEC & 0xff, 0x1B & 0xff, 0x2C & 0xff, 0x80 & 0xff, 0xF7 & 0xff, 0x74 & 0xff,
			0xE7 & 0xff, 0xFF & 0xff, 0x21 & 0xff, 0x5A & 0xff, 0x6A & 0xff, 0x54 & 0xff, 0x1E & 0xff, 0x41 & 0xff,
			0x31 & 0xff, 0x92 & 0xff, 0x35 & 0xff, 0xC4 & 0xff, 0x33 & 0xff, 0x07 & 0xff, 0x0A & 0xff, 0xBA & 0xff,
			0x7E & 0xff, 0x0E & 0xff, 0x34 & 0xff, 0x88 & 0xff, 0xB1 & 0xff, 0x98 & 0xff, 0x7C & 0xff, 0xF3 & 0xff,
			0x3D & 0xff, 0x60 & 0xff, 0x6C & 0xff, 0x7B & 0xff, 0xCA & 0xff, 0xD3 & 0xff, 0x1F & 0xff, 0x32 & 0xff,
			0x65 & 0xff, 0x04 & 0xff, 0x28 & 0xff, 0x64 & 0xff, 0xBE & 0xff, 0x85 & 0xff, 0x9B & 0xff, 0x2F & 0xff,
			0x59 & 0xff, 0x8A & 0xff, 0xD7 & 0xff, 0xB0 & 0xff, 0x25 & 0xff, 0xAC & 0xff, 0xAF & 0xff, 0x12 & 0xff,
			0x03 & 0xff, 0xE2 & 0xff, 0xF2 & 0xff };

	static long magic() {
		long uVar1 = xkey[0];
		long uVar6 = (xkey[3] + uVar1) & 0xffffffffL;
		long uVar3 = xkey[1];
		long uVar4 = xkey[4] ^ uVar3;
		long uVar5 = uVar4 >>> 0x10;
		long uVar2 = uVar6 * 0x10000 & 0xffffffffL | uVar5;
		uVar2 = (uVar5 << 0x18 & 0xffffffffL | uVar2 >>> 8) ^ (uVar5 << 0x12 & 0xffffffffL | uVar2 >>> 0xe)
				^ (uVar6 >>> 6 & 0x3ff | uVar2 << 10 & 0xffffffffL) ^ (uVar6 >>> 0xe & 3 | uVar2 << 2 & 0xffffffffL)
				^ uVar2;
		xkey[0] = box2[(int) (uVar2 & 0xff)] | box1[(int) (uVar2 >>> 8 & 0xff)] << 8 & 0xffffffffL
				| box2[(int) (uVar2 >>> 0x10 & 0xff)] << 0x10 & 0xffffffffL
				| box1[(int) (uVar2 >>> 0x18 & 0xff)] << 0x18 & 0xffffffffL;
		uVar6 = uVar6 >>> 0x10;
		uVar2 = uVar4 << 0x10 & 0xffffffffL | uVar6;
		uVar2 = (uVar6 << 0x1e & 0xffffffffL | uVar2 >>> 2) ^ (uVar6 << 0x16 & 0xffffffffL | uVar2 >>> 10)
				^ (uVar4 >>> 2 & 0x3fff | uVar2 << 0xe & 0xffffffffL) ^ (uVar4 >>> 8 & 0xff | uVar2 << 8 & 0xffffffffL)
				^ uVar2;
		xkey[1] = box2[(int) (uVar2 & 0xff)] | box1[(int) (uVar2 >>> 8 & 0xff)] << 8 & 0xffffffffL
				| box2[(int) (uVar2 >>> 0x10 & 0xff)] << 0x10 & 0xffffffffL
				| box1[(int) (uVar2 >>> 0x18 & 0xff)] << 0x18 & 0xffffffffL;
		return ((xkey[2] ^ uVar1) + uVar3) & 0xffffffffL;
	}

	/**
	 * reverseBytes Reformats a Little Endian value to bigEndian
	 *
	 * @param val the value to transform
	 * @return Big Endian Value
	 */
	public static long long2LittleEndian(long val) {
		return ((val & 0xff00000000000000L) >>> 56) + (((val & 0x00ff000000000000L) >>> 48) << 8)
				+ (((val & 0x0000ff0000000000L) >>> 40) << 16) + (((val & 0x000000ff00000000L) >>> 32) << 24)
				+ (((val & 0x00000000ff000000L) >>> 24) << 32) + (((val & 0x0000000000ff0000L) >>> 16) << 40)
				+ (((val & 0x000000000000ff00L) >>> 8) << 48) + (((val & 0x00000000000000ffL)) << 56);
	}

	static void swap() {
		xkey[2] = ((xkey[21] << 1) & 0xFFFF0000 | xkey[20] & 0xffff) & 0xffffffffL;
		xkey[3] = ((xkey[15] >>> 15) | (xkey[17] << 16 & 0xffffffffL)) & 0xffffffffL;
		xkey[4] = ((xkey[11] >>> 15) | (xkey[13] << 16 & 0xffffffffL)) & 0xffffffffL;
		xkey[5] = ((xkey[6] >>> 15) | (xkey[8] << 16 & 0xffffffffL)) & 0xffffffffL;
	}

	/**
	 *
	 * @param in
	 * @return
	 */
	public static String checkSum(String in) {
		byte[] digest = null;
		try {
			MessageDigest md5 = MessageDigest.getInstance("md5");
			digest = md5.digest(in.getBytes("utf-8"));
		} catch (NoSuchAlgorithmException | UnsupportedEncodingException e) {
			e.printStackTrace();
		}
		return byte2hex(digest);
	}

	/**
	 *
	 * @param b
	 * @return
	 *
	 *         (From CSDN)
	 */
	public static String byte2hex(byte[] b) {
		StringBuilder hs = new StringBuilder();
		String stmp = "";
		for (byte value : b) {
			// 为了保证二进制机器数不变，这里需要& 0XFF
			stmp = (Integer.toHexString(value & 0XFF));
			// 如果只有一位，需要在前面补上0凑足两位
			if (stmp.length() == 1) {
				hs.append("0").append(stmp);
			} else {
				hs.append(stmp);
			}
		}
		return hs.toString();
	}

	/**
	 *
	 * @param url
	 * @param body
	 * @param AlgoID
	 * @return
	 * @throws Exception
	 */
	public static Result doPost(URL url, String body, Object access) throws Exception {
		HttpURLConnection con = (HttpURLConnection) url.openConnection();
		con.setRequestMethod("POST");
		con.setRequestProperty("User-Agent", "CCTP/android8Huizhou_vpn/2075");
		con.setRequestProperty("Algo-ID", "00000000-0000-0000-0000-000000000000");
		con.setRequestProperty("Client-ID", UUID.randomUUID().toString());
		con.setRequestProperty("CDC-Checksum", checkSum(body));

		con.setDoOutput(true);
		con.setDoInput(true);
		DataOutputStream wr = new DataOutputStream(con.getOutputStream());
		wr.writeBytes(body);
		wr.flush();
		wr.close();

		if (access != null || con.getHeaderField("Content-Length") == null) {
			String result = "";
			BufferedReader in = new BufferedReader(new InputStreamReader(con.getInputStream(), "utf8"));
			String line;
			while ((line = in.readLine()) != null) {
				result += line;
			}
			if (in != null) {
				in.close();
			}
			return new ZsmPatcher().new Result("", result.getBytes());
		} else {
			int len = Integer.parseInt(con.getHeaderField("Content-Length"));
			byte[] result = new byte[len];
			InputStream ip = con.getInputStream();
			while (len > 0) {
				int read = ip.read(result, result.length - len, len);
				if (read < 0)
					break;
				len -= read;
			}
			if (ip != null)
				ip.close();
			return new ZsmPatcher().new Result("", result);
		}
	}

	class Result {
		public Result(String lastError, byte[] bytes) {
			result = bytes;
			Error_Code = lastError;
		}

		public byte[] result;
		public String Error_Code;

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;
			result = prime * result + Arrays.hashCode(this.result);
			result = prime * result + Objects.hash(Error_Code);
			return result;
		}

		@Override
		public boolean equals(Object obj) {
			if (this == obj)
				return true;
			if (!(obj instanceof Result))
				return false;
			Result other = (Result) obj;
			return Objects.equals(Error_Code, other.Error_Code) && Arrays.equals(result, other.result);
		}

		@Override
		public String toString() {
			return String.format("Result [result=%s, Error_Code=%s]", Arrays.toString(result), Error_Code);
		}
	}

	public static byte[] toByteArray3(String filename) throws IOException {
		FileChannel fc = null;
		RandomAccessFile rc = null;
		try {
			try {
				fc = (rc = new RandomAccessFile(filename, "r")).getChannel();
				MappedByteBuffer byteBuffer = fc.map(FileChannel.MapMode.READ_ONLY, 0L, fc.size()).load();
				byte[] result = new byte[(int) fc.size()];
				if (byteBuffer.remaining() > 0) {
					byteBuffer.get(result, 0, byteBuffer.remaining());
				}
				fc.close();
				rc.close();
				return result;
			} finally {
				fc.close();
				rc.close();
			}
		} catch (IOException e2) {
			e2.printStackTrace();
			throw e2;
		}
	}

	public static byte[] patch(byte[] b) throws Throwable {
			BufferedInputStream bufferedInputStream = new BufferedInputStream(new ByteArrayInputStream(b));
			byte[] bArr = new byte[3]; // 001
			bufferedInputStream.read(bArr, 0, 3);
			new String(bArr);
			byte[] bArr2 = new byte[1];
			bufferedInputStream.read(bArr2);
			int i2 = bArr2[0] & 255;
			byte[] bArr3 = new byte[i2];
			bufferedInputStream.read(bArr3, 0, i2);
			new String(bArr3);
			bufferedInputStream.read(bArr2);
			int i3 = bArr2[0] & 255;
			byte[] bArr4 = new byte[i3];
			bufferedInputStream.read(bArr4, 0, i3);
			new String(bArr4);
			ByteArrayOutputStream bufferedOutputStream = new ByteArrayOutputStream();
			// bufferedOutputStream.write(KeyID.getBytes());
			// bufferedOutputStream.write(UnKnown.length());
			// bufferedOutputStream.write(UnKnown.getBytes());
			// bufferedOutputStream.write(AlgoID.length());
			// bufferedOutputStream.write(AlgoID.getBytes());
			int available = bufferedInputStream.available();
			byte[] bArr5 = new byte[available];
			bufferedInputStream.read(bArr5, 0, available);
			int length = bArr5.length - 1 - 8;
			int iVar1 = 0x20;
			do {
				swap();
				long uVar2 = magic();
				long uVar6 = xkey[19];
				long uVar7 = xkey[16];
				long uVar9 = xkey[10];
				long uVar4 = xkey[6];
				// long uVar3 = xkey[21];
				// long uVar8 = xkey[10];
				xkey[6] = xkey[7];
				xkey[7] = xkey[8];
				xkey[8] = xkey[9];
				xkey[9] = xkey[10];
				xkey[10] = xkey[11];
				xkey[11] = xkey[12];
				xkey[12] = xkey[13];
				xkey[13] = xkey[14];
				xkey[14] = xkey[15];
				xkey[15] = xkey[16];
				xkey[16] = xkey[17];
				xkey[17] = xkey[18];
				xkey[18] = xkey[19];
				xkey[19] = xkey[20];
				xkey[20] = xkey[21];
				uVar4 = (uVar4 >> 0x17 | (uVar4 & 0x7fffff) << 8) + uVar4;
				// signed integer
				long iVar5 = (uVar9 >> 0xb | (uVar9 & 0x7ff) << 0x14) - ((int) uVar4 >> 0x1f);
				uVar9 = iVar5 + uVar4;
				iVar5 = (uVar7 >> 10 | (uVar7 & 0x3ff) << 0x15) - ((int) (iVar5 + (uVar4 & 0x7fffffff)) >> 0x1f);
				uVar4 = iVar5 + uVar9;
				iVar5 = (uVar6 >> 0xe | (uVar6 & 0x3fff) << 0x11) - ((int) (iVar5 + (uVar9 & 0x7fffffff)) >> 0x1f);
				uVar9 = iVar5 + uVar4;
				iVar5 = (xkey[21] >> 0x10 | (xkey[21] & 0xffff) << 0xf)
						- ((int) (iVar5 + (uVar4 & 0x7fffffff)) >> 0x1f);
				uVar4 = iVar5 + uVar9;
				iVar5 = (uVar2 >> 1) - ((int) (iVar5 + (uVar9 & 0x7fffffff)) >> 0x1f);
				xkey[21] = (iVar5 + uVar4 & 0x7fffffff) - ((int) (iVar5 + (uVar4 & 0x7fffffff)) >> 0x1f);
				iVar1--;
			} while (iVar1 != 0);
			swap();
			magic();
			int cc = 9;
			System.out.println("Length: " + length);
			for (int j = length >>> 2; j > 0; j--) {
				d0();
				swap();
				long uVar9 = magic();
				long data_in = (((int) bArr5[cc] & 0xff) | ((int) bArr5[cc + 1] & 0xff) << 8
						| ((int) bArr5[cc + 2] & 0xff) << 16 | ((int) bArr5[cc + 3] & 0xff) << 24) & 0xffffffffL;
				// System.out.println(" " + Long.toHexString(data_in));
				// System.out.println(" " + Long.toHexString( (0x5A | 0x24 << 8 | 0x6A << 16 |
				// 0xCD << 24) & 0xffffffffL ) );
				uVar9 = xkey[5] ^ uVar9 ^ (data_in << 0x18 & 0xffffffffL | (data_in & 0xff00) << 8 & 0xffffffffL
						| data_in >> 0x18 | data_in >> 8 & 0xff00);
				data_in = (uVar9 << 0x18) & 0xffffffffL | (uVar9 & 0xff00) << 8 & 0xffffffffL | uVar9 >> 0x18
						| uVar9 >> 8 & 0xff00;
				// System.out.println(" " + Long.toHexString(data_in));
				bArr5[cc + 3] = (byte) (data_in >>> 24);
				bArr5[cc + 2] = (byte) ((data_in & 0xff0000) >> 16);
				bArr5[cc + 1] = (byte) ((data_in & 0xff00) >> 8);
				bArr5[cc] = (byte) (data_in & 0xff);
				cc += 4;
			}

			byte[] encodeZSM = decodeZSM(new ByteArrayInputStream(bArr5));
			bufferedOutputStream.write(encodeZSM);
			bufferedOutputStream.close();
			return bufferedOutputStream.toByteArray();
	}

	static void d0() {
		long uVar2 = xkey[19];
		long uVar6 = xkey[16];
		long uVar7 = xkey[10];
		long uVar9 = xkey[6];
		long uVar3 = xkey[21];
		long uVar8 = xkey[10];
		xkey[6] = xkey[7];
		xkey[7] = xkey[8];
		xkey[8] = xkey[9];
		xkey[9] = xkey[10];
		xkey[10] = xkey[11];
		xkey[11] = xkey[12];
		xkey[12] = xkey[13];
		xkey[13] = xkey[14];
		xkey[14] = xkey[15];
		xkey[15] = xkey[16];
		xkey[16] = xkey[17];
		xkey[17] = xkey[18];
		xkey[18] = xkey[19];
		xkey[19] = xkey[20];
		xkey[20] = xkey[21];
		uVar9 = (uVar9 >> 0x17 | (uVar9 & 0x7fffff) << 8) + uVar9;
		long iVar1 = (uVar7 >> 0xb | (uVar7 & 0x7ff) << 0x14) - ((int) uVar9 >> 0x1f);
		long uVar10 = iVar1 + uVar9;
		iVar1 = (uVar6 >> 10 | (uVar6 & 0x3ff) << 0x15) - ((int) (iVar1 + (uVar9 & 0x7fffffff)) >> 0x1f);
		uVar7 = iVar1 + uVar10;
		iVar1 = (uVar2 >> 0xe | (uVar2 & 0x3fff) << 0x11) - ((int) (iVar1 + (uVar10 & 0x7fffffff)) >> 0x1f);
		uVar9 = iVar1 + uVar7;
		iVar1 = (xkey[21] >> 0x10 | (xkey[21] & 0xffff) << 0xf) - ((int) (iVar1 + (uVar7 & 0x7fffffff)) >> 0x1f);
		xkey[21] = (iVar1 + uVar9 & 0x7fffffff) - ((int) (iVar1 + (uVar9 & 0x7fffffff)) >> 0x1f);
		xkey[9] = uVar8;
		xkey[15] = uVar6;
		xkey[18] = uVar2;
		xkey[20] = uVar3;
	}

	private static byte[] decodeZSM(InputStream inputStream) throws Exception {
		byte[] bArr = new byte[5];
		if (inputStream.read(bArr, 0, 5) == 5) {
			Decoder decoder = new Decoder();
			if (decoder.SetDecoderProperties(bArr)) {
				long i2 = 0;
				for (int i = 0; i < 3; i++) {
					int read = inputStream.read();
					if (read >= 0) {
						i2 = (long) ((read << (i * 8)) | i2);
					} else {
						throw new Exception("Can't read stream size");
					}
				}
				inputStream.read(); // Change 11/21 : .... it works
				ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
				if (decoder.Code(inputStream, byteArrayOutputStream, i2)) {
					inputStream.close();
					return byteArrayOutputStream.toByteArray();

				} else {
					throw new Exception("Error in data stream");
				}
			} else {
				throw new Exception("Incorrect stream properties");
			}
		} else {
			throw new Exception("input .lzma file is too short");
		}
	}
}